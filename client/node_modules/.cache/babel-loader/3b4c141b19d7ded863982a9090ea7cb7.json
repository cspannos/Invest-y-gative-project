{"ast":null,"code":"'use strict';\n\nvar CID = require('cids');\n\nvar protons = require('protons');\n\nvar proto = protons(require('./dag.proto.js'));\n\nvar resolver = require('./resolver');\n\nvar DAGLink = require('./dag-link');\n\nvar DAGNode = require('./dag-node');\n\nvar multihashing = require('multihashing-async');\n\nvar waterfall = require('async/waterfall');\n\nvar setImmediate = require('async/setImmediate');\n\nexports = module.exports;\n/**\n * @callback CidCallback\n * @param {?Error} error - Error if getting the CID failed\n * @param {?CID} cid - CID if call was successful\n */\n\n/**\n * Get the CID of the DAG-Node.\n *\n * @param {Object} dagNode - Internal representation\n * @param {Object} [options] - Options to create the CID\n * @param {number} [options.version] - CID version number. Defaults to zero if hashAlg == 'sha2-256'; otherwise, 1.\n * @param {string} [options.hashAlg] - Defaults to hashAlg for the resolver\n * @param {CidCallback} callback - Callback that handles the return value\n * @returns {void}\n */\n\nfunction cid(dagNode, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  var hashAlg = options.hashAlg || resolver.defaultHashAlg;\n  var version = options.version;\n\n  if (typeof version === 'undefined') {\n    version = hashAlg === 'sha2-256' ? 0 : 1;\n  }\n\n  waterfall([function (cb) {\n    if (Buffer.isBuffer(dagNode)) {\n      return cb(null, dagNode);\n    }\n\n    serialize(dagNode, cb);\n  }, function (serialized, cb) {\n    return multihashing(serialized, hashAlg, cb);\n  }, function (mh, cb) {\n    return cb(null, new CID(version, resolver.multicodec, mh));\n  }], callback);\n}\n\nfunction serialize(node, callback) {\n  var serialized;\n  var data = node.data,\n      _node$links = node.links,\n      links = _node$links === void 0 ? [] : _node$links; // If the node is not an instance of a DAGNode, the link.hash might be a Base58 encoded string; decode it\n\n  if (!DAGNode.isDAGNode(node) && links) {\n    links = links.map(function (link) {\n      return DAGLink.isDAGLink(link) ? link : DAGLink.util.createDagLinkFromB58EncodedHash(link);\n    });\n  }\n\n  try {\n    serialized = proto.PBNode.encode(toProtoBuf({\n      data: data,\n      links: links\n    }));\n  } catch (err) {\n    return callback(err);\n  }\n\n  callback(null, serialized);\n}\n\nfunction deserialize(buffer, callback) {\n  var pbn = proto.PBNode.decode(buffer);\n  var links = pbn.Links.map(function (link) {\n    return new DAGLink(link.Name, link.Tsize, link.Hash);\n  });\n  var data = pbn.Data == null ? Buffer.alloc(0) : pbn.Data;\n  setImmediate(function () {\n    return callback(null, new DAGNode(data, links, buffer.length));\n  });\n}\n\nfunction toProtoBuf(node) {\n  var pbn = {};\n\n  if (node.data && node.data.length > 0) {\n    pbn.Data = node.data;\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization `null !== new Buffer(0)`\n    pbn.Data = null;\n  }\n\n  if (node.links && node.links.length > 0) {\n    pbn.Links = node.links.map(function (link) {\n      return {\n        Hash: link.cid.buffer,\n        Name: link.name,\n        Tsize: link.size\n      };\n    });\n  } else {\n    pbn.Links = null;\n  }\n\n  return pbn;\n}\n\nexports.serialize = serialize;\nexports.deserialize = deserialize;\nexports.cid = cid;","map":null,"metadata":{},"sourceType":"script"}