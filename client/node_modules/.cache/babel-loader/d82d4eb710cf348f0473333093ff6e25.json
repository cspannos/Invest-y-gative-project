{"ast":null,"code":"'use strict';\n\nvar util = require('./util');\n\nvar traverse = require('traverse');\n\nvar CID = require('cids');\n\nexports = module.exports;\nexports.multicodec = 'dag-cbor';\nexports.defaultHashAlg = 'sha2-256';\n/*\n * resolve: receives a path and a binary blob and returns the value on path,\n * throw if not possible. `binaryBlob` is CBOR encoded data.\n */\n\nexports.resolve = function (binaryBlob, path, callback) {\n  if (typeof path === 'function') {\n    callback = path;\n    path = undefined;\n  }\n\n  util.deserialize(binaryBlob, function (err, node) {\n    if (err) {\n      return callback(err);\n    } // root\n\n\n    if (!path || path === '/') {\n      return callback(null, {\n        value: node,\n        remainderPath: ''\n      });\n    } // within scope\n\n\n    var parts = path.split('/');\n    var val = traverse(node).get(parts);\n\n    if (val !== undefined) {\n      return callback(null, {\n        value: val,\n        remainderPath: ''\n      });\n    } // out of scope\n\n\n    var value;\n    var len = parts.length;\n\n    for (var i = 0; i < len; i++) {\n      var partialPath = parts.shift();\n\n      if (Array.isArray(node) && !Buffer.isBuffer(node)) {\n        value = node[Number(partialPath)];\n      }\n\n      if (node[partialPath]) {\n        value = node[partialPath];\n      } else {\n        // can't traverse more\n        if (!value) {\n          return callback(new Error('path not available at root'));\n        } else {\n          parts.unshift(partialPath);\n          return callback(null, {\n            value: value,\n            remainderPath: parts.join('/')\n          });\n        }\n      }\n\n      node = value;\n    }\n  });\n};\n\nfunction flattenObject(obj, delimiter) {\n  delimiter = delimiter || '/';\n\n  if (Object.keys(obj).length === 0) {\n    return [];\n  }\n\n  return traverse(obj).reduce(function (acc, x) {\n    if (CID.isCID(x)) {\n      this.update(undefined);\n    }\n\n    var path = this.path.join(delimiter);\n\n    if (path !== '') {\n      acc.push({\n        path: path,\n        value: x\n      });\n    }\n\n    return acc;\n  }, []);\n}\n/*\n * tree: returns a flattened array with paths: values of the project. options\n * are option (i.e. nestness)\n */\n\n\nexports.tree = function (binaryBlob, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  options = options || {};\n  util.deserialize(binaryBlob, function (err, node) {\n    if (err) {\n      return callback(err);\n    }\n\n    var flat = flattenObject(node);\n    var paths = flat.map(function (el) {\n      return el.path;\n    });\n    callback(null, paths);\n  });\n};\n\nexports.isLink = function (binaryBlob, path, callback) {\n  exports.resolve(binaryBlob, path, function (err, result) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (result.remainderPath.length > 0) {\n      return callback(new Error('path out of scope'));\n    }\n\n    if (CID.isCID(result.value)) {\n      callback(null, result.value);\n    } else {\n      callback(null, false);\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"script"}